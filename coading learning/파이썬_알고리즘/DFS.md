# ✔️ 깊이우선탐색 (DFS)

시작 정점으로부터 갈 수 있는 하위 정점까지 가장 깊게 탐색하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법

- 모든 정점을 방문할 때 유리하다. 따라서 경우의 수, 순열과 조합 문제에서 많이 사용한다.
- 너비우선탐색에 비해 코드 구현이 간단하다.
  단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 너비우선 탐색이 유리하다.

---

각 정점을 방문했는지 여부를 판별할 방문 체크 리스트가 필요하다.

```python
visited = [False] * n # n은 정점의 개수
```

방문한 정점은 True , 방문하지 않은 정점은 False

---

## ✔️ 반복문을 이용한 DFS

```python
graph = [
    [1,2],
    [0,3,4],
    [0,4,5],
    [1],
    [1,2,6],
    [2],
    [4]
]

visited = [False] * n # 방문 처리 리스트 만들기
def dfs(start):
    stack = [start] # 돌아갈 곳을 기록
    visited[start] = True # 시작 정점 방문 처리

    while stack : # 스택이 빌 때까지 (돌아갈 곳이 없을때까지) 반복
        cur = stack.pop() # 현재 방문 정점 (후입선출)

        for adj in graph[cur]: # 인접한 모든 정점에 대해
            if not visited[adj]: # 아직 방문하지 않았다면
                visited[adj] = True # 방문 처리
                stack.append(adj) # 스택에 넣기
dfs(0) # 0번 정점에서 시작
```

> [백준\_바이러스](https://www.acmicpc.net/problem/2606) 풀어보기
